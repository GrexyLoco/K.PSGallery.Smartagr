name: üöÄ Smart PowerShell Module Release Pipeline

# üéØ Triggers: Push to master branch (e.g., PR merge)
# üìã Required Repository Variables:
# - UBUNTU_VERSION: Ubuntu runner version (e.g., "ubuntu-22.04")
# - MODULE_NAME: PowerShell module name for dispatch
# - TARGET_REPOSITORY: Target repository for auto-publish dispatch
# üìã Required Repository Secrets:
# - REPO_DISPATCH_TOKEN: Personal Access Token for cross-repo dispatch

on:
  push:
    branches: [master, main]
  workflow_dispatch:
    # Optional manual trigger for testing
    inputs:
      test:
        description: "Run validation only (no dispatch)"
        required: false
        default: false
        type: boolean

env:
  # üåç Global environment variables for consistency
  RELEASE_AUTHOR: "github-actions[bot]"
  RELEASE_EMAIL: "github-actions[bot]@users.noreply.github.com"
  # üì¶ Module Configuration (can be overridden by repository variables)
  MODULE_NAME: ${{ vars.MODULE_NAME || 'K.PSGallery.SmartAgr' }}
  TARGET_REPOSITORY: ${{ vars.TARGET_REPOSITORY || 'GrexyLoco/K.PSGallery' }}
  
  # üîÑ Smartagr Import Strategy (Bootstrap Configuration)
  # ‚ö†Ô∏è IMPORTANT: This controls where Smartagr module is loaded from during tag creation
  # 
  # Repository Variable: SMARTAGR_USE_PSGALLERY (boolean)
  #   - Not set or 'false' = Import from LOCAL repository (default, self-hosting)
  #   - 'true'            = Import from PSGallery (stable releases, one-version-behind)
  # 
  # üìå Migration Path:
  #    1. Pre-v1.0.0:  No variable set ‚Üí LOCAL import (bootstrap phase)
  #    2. Post-v1.0.0: Set variable to 'true' ‚Üí PSGallery import (stable phase)
  #    3. Breaking changes: Set to 'false' temporarily ‚Üí LOCAL import
  # 
  # ‚ö†Ô∏è Trade-offs:
  #    - Local:    Version N tags version N (self-tagging, breaking changes supported)
  #    - PSGallery: Version N tags version N+1 (feature lag, stable releases only)
  # 
  # üîß How to configure: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Variables
  #    Variable name: SMARTAGR_USE_PSGALLERY
  #    Variable value: true (for PSGallery) or false/unset (for local)
  USE_PSGALLERY_SMARTAGR: ${{ vars.SMARTAGR_USE_PSGALLERY || 'false' }}

jobs:
  quality-gate:
    name: üîê Quality Gate
    runs-on: ${{ vars.UBUNTU_VERSION || 'ubuntu-22.04' }}
    outputs:
      test-success: ${{ steps.validation.outputs.test-success }}
      total-tests: ${{ steps.validation.outputs.total-tests }}
      passed-tests: ${{ steps.validation.outputs.passed-tests }}
      failed-tests: ${{ steps.validation.outputs.failed-tests }}
      skipped-tests: ${{ steps.validation.outputs.skipped-tests }}
      test-duration: ${{ steps.validation.outputs.test-duration }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîê Validate PowerShell Module
        id: validation
        uses: GrexyLoco/K.Actions.PSModuleValidation@v1.0.1
        with:
          test-path: "./Tests"
          output-path: "./TestResults.xml"
          validate-all-codebase: "false"
          github-token: ${{ secrets.GITHUB_TOKEN }}
          module-name: ${{ env.MODULE_NAME }}

  version-and-tag:
    name: üì¶ Version & Tag
    runs-on: ubuntu-latest
    needs: quality-gate
    if: needs.quality-gate.outputs.test-success == 'true'
    outputs:
      new-version: ${{ steps.version.outputs.newVersion }}
      current-version: ${{ steps.version.outputs.currentVersion }}
      bump-type: ${{ steps.version.outputs.bumpType }}
      last-release-tag: ${{ steps.version.outputs.lastReleaseTag }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üî¢ Calculate next version
        id: version
        uses: GrexyLoco/K.Actions.NextVersion@v1
        with:
          manifestPath: './K.PSGallery.Smartagr.psd1'
          branchName: ${{ github.ref_name }}
          targetBranch: 'master'

      - name: üìù Update Manifest Version
        if: steps.version.outputs.newVersion != ''
        shell: pwsh
        run: |
          $manifestPath = './K.PSGallery.Smartagr.psd1'
          $newVersion = '${{ steps.version.outputs.newVersion }}'
          
          Write-Host "üîÑ Updating manifest version to $newVersion..."
          
          # Read current manifest
          $content = Get-Content $manifestPath -Raw
          
          # Update ModuleVersion with regex
          $updatedContent = $content -replace "ModuleVersion\s*=\s*'[^']*'", "ModuleVersion = '$newVersion'"
          
          # Verify the replacement worked
          if ($updatedContent -notmatch "ModuleVersion\s*=\s*'$newVersion'") {
            Write-Error "‚ùå MANIFEST UPDATE FAILED!"
            Write-Error ""
            Write-Error "‚ö†Ô∏è  CRITICAL: Das Manifest konnte nicht aktualisiert werden."
            Write-Error "    Dies f√ºhrt zu einem Konflikt zwischen Git-Tags und Manifest-Version."
            Write-Error ""
            Write-Error "üìã M√∂gliche Ursachen:"
            Write-Error "    ‚Ä¢ ModuleVersion-Format im Manifest ist ung√ºltig"
            Write-Error "    ‚Ä¢ Regex-Pattern konnte Version nicht finden"
            Write-Error "    ‚Ä¢ Datei ist schreibgesch√ºtzt"
            Write-Error ""
            Write-Error "üîß Manuelle L√∂sung erforderlich:"
            Write-Error "    1. Pr√ºfe K.PSGallery.Smartagr.psd1 auf korrekte ModuleVersion-Syntax"
            Write-Error "    2. Aktualisiere ModuleVersion manuell auf '$newVersion'"
            Write-Error "    3. Commit mit Message: 'chore: update manifest to $newVersion [skip ci]'"
            Write-Error ""
            exit 1
          }
          
          # Write updated content back
          Set-Content -Path $manifestPath -Value $updatedContent -NoNewline
          
          Write-Host "‚úÖ Manifest successfully updated to version $newVersion"
          
          # Configure git
          git config user.name "${{ env.RELEASE_AUTHOR }}"
          git config user.email "${{ env.RELEASE_EMAIL }}"
          
          # Commit the updated manifest
          git add $manifestPath
          git commit -m "chore: update manifest to $newVersion [skip ci]"
          git push origin ${{ github.ref_name }}
          
          Write-Host "‚úÖ Manifest changes committed and pushed"

      # TEMPORARY: Simple tag creation to publish the improved version to PSGallery
      # TODO: Re-enable Smartagr tagging after this version is published
      # - name: üè∑Ô∏è Create Git Tag (Simple - Temporary)
      #   if: steps.version.outputs.newVersion != ''
      #   run: |
      #     git config user.name "${{ env.RELEASE_AUTHOR }}"
      #     git config user.email "${{ env.RELEASE_EMAIL }}"
          
      #     # Check if tag already exists
      #     if git rev-parse "v${{ steps.version.outputs.newVersion }}" >/dev/null 2>&1; then
      #       echo "‚ö†Ô∏è Tag v${{ steps.version.outputs.newVersion }} already exists - skipping"
      #     else
      #       git tag -a "v${{ steps.version.outputs.newVersion }}" -m "Release v${{ steps.version.outputs.newVersion }}"
      #       git push origin "v${{ steps.version.outputs.newVersion }}"
      #       echo "‚úÖ Tag v${{ steps.version.outputs.newVersion }} successfully created"
      #     fi

      # DISABLED: Smartagr-based tagging (will be re-enabled after next publish)
      - name: üè∑Ô∏è Create semantic release tags with Smartagr 
        if: steps.version.outputs.newVersion != ''
        shell: pwsh
        run: |
          # üîß Configure Git for tagging
          git config user.name "${{ env.RELEASE_AUTHOR }}"
          git config user.email "${{ env.RELEASE_EMAIL }}"
          
          # üì¶ Import Smartagr module (strategy controlled by SMARTAGR_USE_PSGALLERY variable)
          if ('${{ env.USE_PSGALLERY_SMARTAGR }}' -eq 'true') {
            Write-Output "üì¶ Importing K.PSGallery.Smartagr from PSGallery (stable release)..."
            Write-Output "   ‚ÑπÔ∏è  Using published version (one-version-behind strategy)"
            # Ensure we have latest published version
            Install-Module -Name K.PSGallery.Smartagr -Force -Scope CurrentUser -AllowClobber -Verbose
            Import-Module K.PSGallery.Smartagr -Force -Verbose
          } else {
            Write-Output "üì¶ Importing LOCAL K.PSGallery.Smartagr module (self-hosting)..."
            Write-Output "   Path: ${{ github.workspace }}/K.PSGallery.Smartagr.psd1"
            Write-Output "   ‚ÑπÔ∏è  Using local version (bootstrap/breaking-changes mode)"
            Import-Module "${{ github.workspace }}/K.PSGallery.Smartagr.psd1" -Force -Verbose
          }
          
          # üè∑Ô∏è Create semantic release tags (base + smart tags)
          Write-Output "üè∑Ô∏è Creating semantic release tags for v${{ steps.version.outputs.newVersion }}..."
          
          $targetVersion = "v${{ steps.version.outputs.newVersion }}"
          $repoPath = "${{ github.workspace }}"
          
          # Ensure errors are caught
          $ErrorActionPreference = 'Stop'
          
          try {
            $result = New-SemanticReleaseTags `
              -TargetVersion $targetVersion `
              -RepositoryPath $repoPath `
              -Verbose
            
            if ($result.Success) {
              Write-Output $result.Message
              Write-Output "   Target: $($result.TargetVersion)"
              Write-Output "   All tags: $($result.AllTags -join ', ')"
              
              # DEBUG: Output result object structure
              Write-Output ""
              Write-Output "=== DEBUG: Result Object Structure ==="
              Write-Output "Result as JSON:"
              Write-Output ($result | ConvertTo-Json -Depth 3)
              Write-Output ""
              Write-Output "SmartTags type: $($result.SmartTags.GetType().Name)"
              Write-Output "SmartTags count: $($result.SmartTags.Count)"
              Write-Output "SmartTags raw: $($result.SmartTags)"
              Write-Output ""
              Write-Output "MovingTags type: $($result.MovingTags.GetType().Name)"
              Write-Output "MovingTags count: $($result.MovingTags.Count)"
              Write-Output "MovingTags raw: $($result.MovingTags)"
              Write-Output "======================================="
              Write-Output ""
              
              # Format tag lists for summary with markdown backticks
              # Use format operator to avoid YAML escaping issues with double backticks
              $smartTagsList = if ($result.SmartTags.Count -gt 0) { 
                ($result.SmartTags | ForEach-Object { '`{0}`' -f $_ }) -join ', '
              } else { 
                "_(none)_" 
              }
              $movingTagsList = if ($result.MovingTags.Count -gt 0) { 
                ($result.MovingTags | ForEach-Object { '`{0}`' -f $_ }) -join ', '
              } else { 
                "_(none)_" 
              }
              
              # üìù Add summary to GitHub Actions UI
              @"
          ## üè∑Ô∏è Semantic Tag Management (Smartagr)
          
          **Target Version:** ``$($result.TargetVersion)``
          **Bump Type:** ``${{ steps.version.outputs.bumpType }}``
          
          ### ‚úÖ Tags Created
          - **Release Tag:** ``$($result.ReleaseTag)``
          - **Smart Tags:** $smartTagsList
          - **Moving Tags:** $movingTagsList
          
          ### üìä Tag Strategy
          - Smart tags automatically follow the latest release
          - Moving tags always point to newest stable version
          - Major/Minor tags enable flexible version pinning
          
          ---
          *Powered by [K.PSGallery.Smartagr](https://www.powershellgallery.com/packages/K.PSGallery.Smartagr)*
          "@ >> $env:GITHUB_STEP_SUMMARY
              
            } else {
              throw "Semantic tag creation failed: $($result.Message)"
            }
          }
          catch {
            throw
          }

      - name: üìù Release Summary
        if: always()
        shell: bash
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## üì¶ Version Calculation

          **Current Version:** `${{ steps.version.outputs.currentVersion }}`
          **New Version:** `${{ steps.version.outputs.newVersion }}`
          **Bump Type:** `${{ steps.version.outputs.bumpType }}`
          **Last Release Tag:** `${{ steps.version.outputs.lastReleaseTag }}`

          ---
          EOF

  trigger-publish:
    name: üöÄ Trigger Publish via Repo Dispatch (K.PSGallery)
    runs-on: ubuntu-latest
    needs: [quality-gate, version-and-tag]
    if: needs.quality-gate.outputs.test-success == 'true' && needs.version-and-tag.outputs.new-version != ''
    steps:
      - name: üì§ Dispatch to auto-publish workflow
        uses: peter-evans/repository-dispatch@v4
        with:
          token: ${{ secrets.REPO_DISPATCH_TOKEN }}
          repository: ${{ env.TARGET_REPOSITORY }}
          event-type: publish_module
          client-payload: |
            {
              "repo": "${{ github.repository }}",
              "tag": "v${{ needs.version-and-tag.outputs.new-version }}",
              "bump_type": "${{ needs.version-and-tag.outputs.bump-type }}",
              "triggered_by": "${{ github.actor }}",
              "source_url": "https://github.com/${{ github.repository }}",
              "gallery_url": "https://www.powershellgallery.com/packages/${{ env.MODULE_NAME }}/${{ needs.version-and-tag.outputs.new-version }}"
            }

      - name: üìù Dispatch Summary
        if: always()
        shell: bash
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## üöÄ Auto-Publish Pipeline Triggered

          **Module:** `${{ env.MODULE_NAME }}`
          **Target Repository:** `${{ env.TARGET_REPOSITORY }}`
          **Source Repository:** `${{ github.repository }}`
          **Branch:** `${{ github.ref_name }}`
          **Status:** ‚úÖ Dispatch sent successfully

          The auto-publish pipeline will now handle:
          - üî¢ Semantic version calculation
          - üì¶ Module packaging
          - üöÄ PowerShell Gallery publishing
          - üè∑Ô∏è GitHub release creation

          ---
          EOF
